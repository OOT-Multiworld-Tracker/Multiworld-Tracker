<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hello World!</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photon/0.1.2-alpha/css/photon.min.css" integrity="sha512-iYU5oLP7U/WlxMbfqwzP7shmTUzivS/4EbkLi33k/tzwSCb4GZDU3oDo6WYSsDZgYXsuhzqrkCseWcZW3QCBLQ==" crossorigin="anonymous" />
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>

<body>
    <div class="window">
        <header class="toolbar toolbar-header" style="-webkit-app-region: drag">
            <h1 class="title">Ocarina of Time - Multiworld Autotracker</h1>

            <div class="toolbar-actions">
                <div class="btn-group">
                  <button onclick="RenderSidebar(0)" class="btn btn-default">
                    <span class="icon icon-home"></span>
                  </button>
                  <button onclick="RenderSidebar(1)" class="btn btn-default">
                    <span class="icon icon-download"></span>
                  </button>
                  <button onclick="RenderSidebar(2)" class="btn btn-default">
                    <span class="icon icon-network"></span>
                  </button>
                </div>
            
                <div class="btn-group pull-right">
                    <button class="btn btn-default pull-right">
                        <span class="icon icon-minus"></span>
                    </button>
                    <button class="btn btn-default pull-right">
                        <span class="icon icon-doc"></span>
                    </button>
                    <button class="btn btn-default pull-right">
                        <span class="icon icon-cancel"></span>
                    </button>
                </div>
              </div>
        </header>

        <div class="window-content">
            <div class="">
                <div class="pane-group">
                    <div class="pane-sm sidebar">

                    </div>
                    <div class="pane padded">
                        <p>Accessible Locations</p>
                        <div id="avaliable-root"></div>
                        
                        <p>Completed Locations</p>
                        <div id="completed-root"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
<script>if (typeof module === 'object') {window.module = module; module = undefined;};</script>
<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
<script>if (window.module) module = window.module;</script>
</body>
</html>
<script>
    const locations = new Map();
    var locationJson = [];
    const completeLocations = [];
    var save = {"entrance_index":205,"cutscene_number":65523,"world_time":11112,"world_night_flag":true,"zeldaz_string":"ZELDAZ","death_counter":0,"player_name":"undefinedundefinedundefined     ","dd_flag":false,"heart_containers":14,"health":224,"magic_meter_size":0,"magic_current":48,"rupee_count":150,"navi_timer":0,"checksum":0,"age":0,"swords":{"kokiriSword":true,"masterSword":true,"giantKnife":true,"biggoronSword":false},"shields":{"dekuShield":true,"hylianShield":true,"mirrorShield":true},"tunics":{"kokiriTunic":true,"goronTunic":true,"zoraTunic":true},"boots":{"kokiriBoots":true,"ironBoots":true,"hoverBoots":true},"inventory":{"dekuSticks":true,"dekuNuts":true,"bombs":true,"bombchus":true,"magicBeans":true,"fairySlingshot":true,"fairyBow":true,"fireArrows":true,"iceArrows":true,"lightArrows":true,"dinsFire":true,"faroresWind":true,"nayrusLove":true,"ocarina":1,"hookshot":1,"boomerang":true,"lensOfTruth":true,"megatonHammer":true,"bottle_1":20,"bottle_2":21,"bottle_3":22,"bottle_4":23,"childTradeItem":33,"adultTradeItem":45,"wallet":1,"quiver":1,"bulletBag":1,"bombBag":1,"dekuNutsCapacity":1,"dekuSticksCapacity":1,"swimming":1,"strength":1},"questStatus":{"gerudoMembershipCard":true,"stoneOfAgony":true,"displayGoldSkulltulas":true,"goldSkulltulas":0,"heartPieces":0.0625,"zeldasLullaby":true,"eponasSong":true,"sariasSong":true,"sunsSong":true,"songOfTime":true,"songOfStorms":true,"preludeOfLight":true,"minuetOfForest":true,"boleroOfFire":true,"serenadeOfWater":true,"nocturneOfShadow":true,"requiemOfSpirit":true,"lightMedallion":true,"forestMedallion":true,"waterMedallion":true,"fireMedallion":true,"spiritMedallion":true,"shadowMedallion":true,"kokiriEmerald":false,"goronRuby":false,"zoraSapphire":false},"magic_beans_purchased":1}
    var dungeons = [{"name": "Deku Tree", "mq": false}, {"name": "Dodongo's Cave", "mq": false}, {"name": "Bottom of the Well", "mq": false}, {"name": "Jabu Jabu's Belly", "mq": false}, {"name": "Forest Temple", "mq": false}, {"name": "Fire Temple", "mq": false}, {"name": "Water Temple", "mq": false}, {"name": "Shadow Temple", "mq": false}, {"name": "Spirit Temple", "mq": false}, {"name": "Ice Cavern", "mq": false}, {"name": "GTG", "mq": false}, {"name": "Ganon's Castle", "mq": false}];
    var settings = {
    "open_forest":                             "closed",
    "open_kakariko":                           "closed",
    "open_door_of_time":                       false,
    "zora_fountain":                           "closed",
    "gerudo_fortress":                         "fast",
    "bridge":                                  "stones",
    "bridge_stones":                           3,
    "triforce_hunt":                           false,
    "logic_rules":                             "glitchless",
    "bombchus_in_logic":                       true,
    "skip_child_zelda":                        false,
    "no_escape_sequence":                      true,
    "no_guard_stealth":                        true,
    "no_epona_race":                           true,
    "skip_some_minigame_phases":               true,
    "shuffle_kokiri_sword":                    true,
    "shuffle_ocarinas":                        true,
    "shuffle_weird_egg":                       false,
    "shuffle_gerudo_card":                     true,
    "shuffle_song_items":                      "song",
    "shuffle_cows":                            false,
    "shuffle_beans":                           true,
    "shuffle_medigoron_carpet_salesman":       true,
    "owl_drops":                               false,
    "spawn_positions":                         false,
    "shuffle_scrubs":                          "low",
    "shopsanity":                              2,
    "tokensanity":                             "dungeons"
  }
  var worlds = [];
  var myWorld = 1;

    ParseLocations();

    function SaveAlert() {
        SaveState("test-save")
    }

    function SaveState(fileName) {
        const saveFile = {};
        Object.assign(saveFile, {"dungeons":dungeons})
        Object.assign(saveFile, {"settings":settings})
        Object.assign(saveFile, {"save":save})
        Object.assign(saveFile, {"locations":MapToArray(locations)})
        
        localStorage.setItem(`save-${fileName}`, JSON.stringify(saveFile))
    }

    function LoadState(fileName) {
        const file = JSON.parse(localStorage.getItem(fileName));
        dungeons = file.dungeons;
        settings = file.settings;
        save = file.save;
        
        file.locations.forEach((location) => {
            locations.set(location.id, location)
        })

        Rerender()
    }

    function SpoilerUploaded(data) {
        $.getJSON(URL.createObjectURL(data.files[0]), (data) => {
            ParseSpoilerLog(data)
        })
    }

    function MapToArray(map) {
        let array = []
        map.forEach((value) => array.push(value))
        return array
    }

    function ParseSpoilerLog(log) {
        console.log(log)
        for (let i=0;i<Object.keys(log.dungeons["World 1"]).length;i++ ){
            dungeons[i].mq = log.dungeons["World 1"][Object.keys(log.dungeons["World 1"])[i]] == "mq" ? true : false
        }
        settings = log.settings
        worlds = []

        if (settings.world_count > 1) {
            Object.values(log.locations).forEach((world) => {
                worlds.push(world)
            })
        } else {
            worlds.push(log.locations)
        }
        Rerender()
    }

    function ParseLocations () {
        $.getJSON('/json/locations.json', (data) => {
            locationJson = data;
            data.forEach((location) => {
                location.id = locations.size+1

                if (location.logic) {
                    location.logic = eval(location.logic)
                }

                locations.set(location.id, location)
            })

            RenderAvaliable()
        });
    }

    function MarkComplete (props) {
        console.log('Marked as complete: ', props.id)
        locations.get(props.id).completed = true;
        RenderAvaliable();
        RenderCompleted();
    }

    function UnMark (props) {
        console.log('UnMarked as complete: ', props.id)
        locations.get(props.id).completed = false;
        RenderAvaliable();
        RenderCompleted();
    }
</script>

<script>
    if (require) {
        require('electron').ipcRenderer.on('packet', (event, data) => {
            let parsed = JSON.parse(data);

            switch (parsed.payload) {
                case 0:
                    save = JSON.parse(data).data.save
                    RenderAvaliable()
                break;
                case 1: 
                    // Scene payload
                break;
            }
        })
    }
</script>

<script>
    //Mixins
    function CanStunDeku() {
        return save.inventory.fairySlingshot || save.inventory.boomerang || save.inventory.dekuSticks || (save.inventory.bombBag||save.inventory.bombchus) || save.inventory.dekuNuts || save.inventory.dinsFire || save.swords.kokiriSword || save.shields.dekuShield
    }

    function HasExplosives() {
        return save.inventory.bombBag || save.inventory.bombchus
    }

    function CanDamage() {
        return save.swords.kokiriSword || save.inventory.bombchus || save.inventory.bombBag || save.inventory.dekuSticks || (CanUseMagic() && save.inventory.dinsFire) || (save.age == 1 && save.inventory.fairySlingshot)
    }

    function CanExitForest() {
        return settings.open_forest != "closed" || locations.get(1).completed || HasExplosives() || save.inventory.swimming >= 1 || (CanUseMagic() && save.inventory.dinsFire)
    }

    function CanLightFires() {
        return save.inventory.dekuSticks || (CanUseMagic() && save.inventory.dinsFire) || (save.age == 1 && CanUseMagic() && save.inventory.fairyBow && save.inventory.fireArrows)
    }

    function CanUseMagic() {
        return save.magic_meter_size > 1
    }

    function CanBecomeAdult() {
        return settings.open_door_of_time || save.inventory.ocarina >= 1 && save.questStatus.songOfTime
    }

    // Area Entry Mixins
    function CanEnterDodongo() {
        return CanEnterDeathMountain() && (save.inventory.strength >= 1 || HasExplosives());
    }

    function CanEnterDeathMountain() {
        return settings.open_kakariko || (save.inventory.childTradeItem >= 2 || HasExplosives());
    }

    function CanEnterZorasRiver() {
        return save.inventory.swimming >= 1 || HasExplosives() || (CanBecomeAdult() && save.inventory.megatonHammer)
    }

    function CanEnterZorasDomain() {
        return save.inventory.swimming >= 1 || (HasExplosives() || (CanBecomeAdult() && save.inventory.megatonHammer) && (save.inventory.ocarina >= 1 && save.questStatus.sariasSong))
    }

    function CanEnterJabu() {
        return CanEnterZorasDomain()
    }
</script>

<script type="text/babel">
    RenderAvaliable()
    RenderCompleted()

    RenderSidebar();

    function RenderAvaliable() {
        ReactDOM.render(<LocationList/>, document.getElementById('avaliable-root'))
    }
    
    function RenderCompleted() {
        ReactDOM.render(<CompletedLocationList/>, document.getElementById('completed-root'))
    }

    function RenderSidebar(page=0) {
        ReactDOM.unmountComponentAtNode(document.getElementsByClassName("sidebar")[0])
        switch (page) {
            case 0:
            ReactDOM.render((<div>
            <input type="file" onInput={(elem) => {SpoilerUploaded(elem.target)}} title="Upload Spoiler"/>
            <div className="character_name">{save.player_name}</div>
            <div className="world_id">{"World "+myWorld}</div>

            <p>Dungeons</p>
            <div id="dungeon-root"></div>
        </div>), document.getElementsByClassName("sidebar")[0])
        RenderAvaliable()
        ReactDOM.render(<DungeonList/>, document.getElementById('dungeon-root'))
        break;
        case 1:
        ReactDOM.render((<div>
            <button className="btn btn-default" onClick={() => SaveAlert()}>Save</button>
            <p>Files</p>
            <div id="save-root"></div>
        </div>), document.getElementsByClassName("sidebar")[0])
        ReactDOM.render(<SaveList/>, document.getElementById('save-root'))
            break
        case 2:
        ReactDOM.render((<div>
            <p>My World ID</p>
            <input type="number" onInput={(elem) => {myWorld = elem.target.value;ReactDOM.render(<WorldList/>, document.getElementById('world-root'))}}/>
            <p>Worlds</p>
            <div id="world-root"></div>
        </div>), document.getElementsByClassName("sidebar")[0])
        ReactDOM.render(<WorldList/>, document.getElementById('world-root'))
            break
        }

    }

    function RenderWorlds() {
        return worlds.map(world => {
            let items = 0;

            Object.keys(worlds[worlds.indexOf(world)]).map(item => {
                let location = locations.get(Object.keys(worlds[worlds.indexOf(world)]).indexOf(item)+1)
                if (location && worlds[worlds.indexOf(world)][item].player==myWorld && (!location.logic||location.logic())&&!locations.get(location.id).completed)
                    items++
            })

            return (<World name={"World"+(worlds.indexOf(world)+1)} id={worlds.indexOf(world)} items={items}/>)
        })
    }

    function RenderWorldItems(worldId) {
        return Object.keys(worlds[worldId]).map(item => {
            let location = locations.get(Object.keys(worlds[worldId]).indexOf(item)+1);
            console.log(location)
            if (location && worlds[worldId][item].player==myWorld && (!location.logic||location.logic())&&!locations.get(location.id).completed)
                return (<Item location={location.name} name={worlds[worldId][item].item}/>)
        })
    }

    function GetAccessibleLocations () {
        return locationJson.map(location => {
            if ((location.preExit==true||CanExitForest())&&(!location.logic||location.logic())&&!locations.get(location.id).completed)
                return (<Location id={location.id} name={location.name}/>)
        });
    }

    function GetCompleteLocations () {
        return locationJson.map(location => {
            if (locations.get(location.id).completed)
                return (<CompleteLocation id={location.id} name={location.name}/>)
        });
    }

    function Rerender() {
        RenderAvaliable()
    }

    function RenderDungeons () {
        return dungeons.map(dungeon => {
            return (<Dungeon name={dungeon.name} status={dungeon.mq==true?"Master":"Vanilla"}/>)
        })
    }

    function RenderSaves () {
        let files = []
        for (let i=0;i<localStorage.length;i++) {
            let file = localStorage.key(i)
            if (!file)
                break
            files.push(file)
        }
        return files.map(file => {
            return (<Save name={file}/>)
        })
    }

    function ChangeStatus (props) {
        dungeons.forEach((dungeon) => {
            if (dungeon.name == props.name)
                dungeon.mq = !dungeon.mq
        })
        
        ReactDOM.render(<DungeonList/>, document.getElementById('dungeon-root'))
        RenderAvaliable()
    }

    function DungeonList () {
        return (
            <table className="table-striped">
                <thead>
                    <tr>
                        <th>Dungeon</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    {RenderDungeons()}
                </tbody>
            </table>
        )
    }
    
    function SaveList () {
        return (
            <table className="table-striped">
                <thead>
                    <tr>
                        <th>File</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    {RenderSaves()}
                </tbody>
            </table>
        )
    }

    function WorldList () {
        return (
            <table className="table-striped">
                <thead>
                    <tr>
                        <th>World</th>
                        <th>Items</th>
                    </tr>
                </thead>
                <tbody>
                    {RenderWorlds()}
                </tbody>
            </table>
        )
    }

    function WorldItemList (props) {
        return (
            <div>
                <p>World Items</p>
                <table className="table-striped">
                <thead>
                    <tr>
                        <th>Location</th>
                        <th>Items</th>
                    </tr>
                </thead>
                <tbody>
                    {RenderWorldItems(props.id)}
                </tbody>
            </table>
            </div>
        )
    }

    function LocationList () {
        return (
            <table className="table-striped">
                <thead>
                    <tr>
                        <th>Location</th>
                    </tr>
                </thead>
                <tbody>
                    {GetAccessibleLocations()}
                </tbody>
            </table>
        )
    }

    function CompletedLocationList () {
        return (
            <table className="table-striped">
                <thead>
                    <tr>
                        <th>Location</th>
                    </tr>
                </thead>
                <tbody>
                    {GetCompleteLocations()}
                </tbody>
            </table>
        )
    }

    function Dungeon (props) {
        return (
            <tr onClick={() => ChangeStatus(props)}>
                <td>{props.name}</td>
                <td>{props.status}</td>
            </tr>
        )
    }

    function World (props) {
        return (
            <tr onClick={() => ReactDOM.render(<WorldItemList id={props.id}/>, document.getElementById('avaliable-root'))}>
                <td>{props.name}</td>
                <td>{props.items}</td>
            </tr>
        )
    }

    function Item (props) {
        return (
            <tr>
                <td>{props.location}</td>
                <td>{props.name}</td>
            </tr>
        )
    }

    function Save (props) {
        return (
            <tr onClick={() => LoadState(props.name)}>
                <td>{props.name}</td>
                <td></td>
            </tr>
        )
    }

    function Location (props) {
        return (
            <tr onClick={() => MarkComplete(props)}>
                <td>{props.name}</td>
            </tr>
        )
    }

    function CompleteLocation (props) {
        return (
            <tr onClick={() => UnMark(props)}>
                <td>{props.name}</td>
            </tr>
        )
    }
</script>
